name: Build macOS App

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version (e.g., 1.0.0 or 1.0.0-beta.1)'
        required: true
        default: '1.0.0'
      prerelease:
        description: 'Pre-release (for staging)'
        type: boolean
        default: false

env:
  SCHEME: QueenMama
  XCODE_PROJECT: QueenMama.xcodeproj
  TEAM_ID: WNNDDTBPGK

jobs:
  build:
    runs-on: macos-14
    timeout-minutes: 30  # Prevent infinite hangs
    permissions:
      contents: write  # Required for creating releases
    steps:
      - uses: actions/checkout@v4

      - name: Determine release type
        id: release_type
        run: |
          TAG_NAME="${GITHUB_REF_NAME:-${{ github.event.inputs.version }}}"
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT

          # Check if it's a pre-release (contains -beta, -rc, -alpha, etc.)
          if [[ "$TAG_NAME" =~ -(beta|rc|alpha|dev) ]] || [[ "${{ github.event.inputs.prerelease }}" == "true" ]]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
            echo "üì¶ Building PRE-RELEASE: $TAG_NAME"
          else
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
            echo "üöÄ Building PRODUCTION RELEASE: $TAG_NAME"
          fi

      - name: Select Xcode
        run: sudo xcode-select -s /Applications/Xcode_16.2.app

      - name: Install Certificate
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Import certificate
          echo -n "$APPLE_CERTIFICATE" | base64 --decode -o $RUNNER_TEMP/certificate.p12
          security import $RUNNER_TEMP/certificate.p12 \
            -P "$APPLE_CERTIFICATE_PASSWORD" \
            -A \
            -t cert \
            -f pkcs12 \
            -k $KEYCHAIN_PATH

          # Add to keychain search list and set as default
          security list-keychain -d user -s $KEYCHAIN_PATH $(security list-keychains -d user | sed 's/"//g')
          security default-keychain -s $KEYCHAIN_PATH

          # Set partition list
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Verify certificate is available
          echo "Available signing identities:"
          security find-identity -v -p codesigning $KEYCHAIN_PATH

      - name: Build Archive
        run: |
          # Build without signing Swift packages (they'll be re-signed in Export step)
          xcodebuild archive \
            -project $XCODE_PROJECT \
            -scheme $SCHEME \
            -configuration Release \
            -archivePath $RUNNER_TEMP/QueenMama.xcarchive \
            CODE_SIGN_IDENTITY=- \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO \
            -skipPackagePluginValidation \
            -skipMacroValidation

      - name: Export App
        run: |
          # Create export directory
          mkdir -p "$RUNNER_TEMP/export"

          # Copy app from archive (not signed during archive step - we sign manually)
          cp -R "$RUNNER_TEMP/QueenMama.xcarchive/Products/Applications/QueenMama.app" "$RUNNER_TEMP/export/Queen Mama.app"

          APP_PATH="$RUNNER_TEMP/export/Queen Mama.app"
          SIGN_IDENTITY="Developer ID Application: Jerome LAVAL (WNNDDTBPGK)"

          echo "üîê Signing all frameworks and nested components..."

          # Sign all nested executables, XPC services, and helper apps in all frameworks
          # This handles Sparkle, Sentry, PostHog, and any future frameworks
          find "$APP_PATH/Contents/Frameworks" -type d \( -name "*.xpc" -o -name "*.app" \) | while read item; do
            echo "Signing: $item"
            codesign --force --timestamp --options runtime --sign "$SIGN_IDENTITY" "$item" || true
          done

          # Sign standalone executables in frameworks (like Autoupdate)
          find "$APP_PATH/Contents/Frameworks" -type f -perm +111 ! -name "*.dylib" | while read exe; do
            # Skip if it's inside a .app or .xpc bundle (already signed above)
            if [[ "$exe" != *".app/"* && "$exe" != *".xpc/"* ]]; then
              echo "Signing executable: $exe"
              codesign --force --timestamp --options runtime --sign "$SIGN_IDENTITY" "$exe" || true
            fi
          done

          # Sign all frameworks (deepest first to handle nested frameworks)
          find "$APP_PATH/Contents/Frameworks" -type d -name "*.framework" -maxdepth 2 | sort -r | while read fw; do
            echo "Signing framework: $fw"
            codesign --force --timestamp --options runtime --sign "$SIGN_IDENTITY" "$fw"
          done

          # Finally sign the main app with entitlements
          echo "üîê Signing main application..."
          codesign --force --timestamp --options runtime \
            --sign "$SIGN_IDENTITY" \
            --entitlements "mac_app/QueenMama.entitlements" \
            "$APP_PATH"

          # Verify all signatures
          echo "‚úÖ Verifying code signatures:"
          codesign -dv --verbose=2 "$APP_PATH"
          codesign --verify --deep --strict "$APP_PATH" && echo "Deep verification passed!"

      - name: Notarize App
        timeout-minutes: 15  # Notarization timeout
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
        run: |
          echo "üì§ Submitting for notarization..."
          ditto -c -k --keepParent "$RUNNER_TEMP/export/Queen Mama.app" $RUNNER_TEMP/QueenMama.zip

          # Submit and capture output
          NOTARIZE_OUTPUT=$(xcrun notarytool submit $RUNNER_TEMP/QueenMama.zip \
            --apple-id "$APPLE_ID" \
            --team-id "$APPLE_TEAM_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" \
            --wait 2>&1) || true

          echo "$NOTARIZE_OUTPUT"

          # Check if notarization succeeded
          if echo "$NOTARIZE_OUTPUT" | grep -q "status: Accepted"; then
            echo "‚úÖ Notarization successful!"
            xcrun stapler staple "$RUNNER_TEMP/export/Queen Mama.app"
          else
            echo "‚ùå Notarization failed or timed out"
            echo "Continuing without notarization for testing..."
            # Don't fail the build - allow testing unsigned builds
          fi

      - name: Create DMG
        run: |
          # Create a folder for DMG contents
          mkdir -p "$RUNNER_TEMP/dmg-contents"
          cp -R "$RUNNER_TEMP/export/Queen Mama.app" "$RUNNER_TEMP/dmg-contents/"

          # Add symbolic link to Applications folder
          ln -s /Applications "$RUNNER_TEMP/dmg-contents/Applications"

          # Create DMG with both app and Applications shortcut
          hdiutil create -volname "Queen Mama" \
            -srcfolder "$RUNNER_TEMP/dmg-contents" \
            -ov -format UDZO \
            $RUNNER_TEMP/QueenMama.dmg

          echo "üì¶ DMG created: $(ls -lh $RUNNER_TEMP/QueenMama.dmg)"

      - name: Notarize DMG
        timeout-minutes: 15
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
        run: |
          echo "üì§ Notarizing DMG..."
          NOTARIZE_OUTPUT=$(xcrun notarytool submit $RUNNER_TEMP/QueenMama.dmg \
            --apple-id "$APPLE_ID" \
            --team-id "$APPLE_TEAM_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" \
            --wait 2>&1) || true

          echo "$NOTARIZE_OUTPUT"

          if echo "$NOTARIZE_OUTPUT" | grep -q "status: Accepted"; then
            echo "‚úÖ DMG notarization successful!"
            xcrun stapler staple $RUNNER_TEMP/QueenMama.dmg
            echo "‚úÖ DMG stapled successfully!"
          else
            echo "‚ö†Ô∏è DMG notarization failed, continuing anyway..."
          fi

      - name: Get version info
        id: version_info
        run: |
          TAG_NAME="${{ steps.release_type.outputs.tag_name }}"
          # Extract version without 'v' prefix
          VERSION="${TAG_NAME#v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

          # Get build number from Info.plist
          BUILD_NUMBER=$(defaults read "$RUNNER_TEMP/export/Queen Mama.app/Contents/Info" CFBundleVersion)
          echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT

          # Get DMG size
          DMG_SIZE=$(stat -f%z "$RUNNER_TEMP/QueenMama.dmg")
          echo "dmg_size=$DMG_SIZE" >> $GITHUB_OUTPUT

          echo "üì¶ Version: $VERSION, Build: $BUILD_NUMBER, DMG Size: $DMG_SIZE bytes"

      - name: Sign DMG for Sparkle
        id: sparkle_sign
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
        run: |
          if [ -z "$SPARKLE_PRIVATE_KEY" ]; then
            echo "‚ö†Ô∏è SPARKLE_PRIVATE_KEY not set, skipping Sparkle signing"
            echo "signature=" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Download Sparkle tools
          echo "üì• Downloading Sparkle tools..."
          curl -L -o /tmp/Sparkle.tar.xz "https://github.com/sparkle-project/Sparkle/releases/download/2.6.4/Sparkle-2.6.4.tar.xz"
          mkdir -p /tmp/sparkle
          tar -xf /tmp/Sparkle.tar.xz -C /tmp/sparkle

          # Save private key to temp file
          echo "$SPARKLE_PRIVATE_KEY" > /tmp/sparkle_private_key

          # Sign the DMG
          echo "üîê Signing DMG for Sparkle updates..."
          SIGNATURE=$(/tmp/sparkle/bin/sign_update "$RUNNER_TEMP/QueenMama.dmg" --ed-key-file /tmp/sparkle_private_key | grep "sparkle:edSignature" | sed 's/.*sparkle:edSignature="\([^"]*\)".*/\1/')

          # Clean up private key
          rm -f /tmp/sparkle_private_key

          echo "‚úÖ Sparkle signature generated"
          echo "signature=$SIGNATURE" >> $GITHUB_OUTPUT

      - name: Rename DMG with version
        run: |
          VERSION="${{ steps.version_info.outputs.version }}"
          mv "$RUNNER_TEMP/QueenMama.dmg" "$RUNNER_TEMP/QueenMama-${VERSION}.dmg"
          echo "üì¶ DMG renamed to: QueenMama-${VERSION}.dmg"

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          files: ${{ runner.temp }}/QueenMama-${{ steps.version_info.outputs.version }}.dmg
          prerelease: ${{ steps.release_type.outputs.is_prerelease }}
          body: |
            ## Queen Mama ${{ steps.release_type.outputs.tag_name }}

            ${{ steps.release_type.outputs.is_prerelease == 'true' && '‚ö†Ô∏è **PRE-RELEASE** - Pour tests uniquement (staging.queenmama.co)' || 'üöÄ **PRODUCTION RELEASE** - Version stable (queenmama.co)' }}

            **Installation:** T√©l√©charger le DMG, glisser dans Applications.
            **Requis:** macOS 14.2+
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update appcast.xml
        if: steps.sparkle_sign.outputs.signature != '' && steps.release_type.outputs.is_prerelease == 'false'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ steps.version_info.outputs.version }}"
          BUILD_NUMBER="${{ steps.version_info.outputs.build_number }}"
          DMG_SIZE="${{ steps.version_info.outputs.dmg_size }}"
          SIGNATURE="${{ steps.sparkle_sign.outputs.signature }}"
          TAG_NAME="${{ steps.release_type.outputs.tag_name }}"

          echo "üìù Updating appcast.xml for version $VERSION..."

          # Configure git
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          # Checkout main branch
          git fetch origin main
          git checkout main

          # Use Python to safely update XML
          python3 << PYTHON_SCRIPT
          import xml.etree.ElementTree as ET
          from datetime import datetime, timezone

          # Parse existing appcast
          tree = ET.parse('landing/public/appcast.xml')
          root = tree.getroot()

          # Register Sparkle namespace
          ET.register_namespace('sparkle', 'http://www.andymatuschak.org/xml-namespaces/sparkle')
          ET.register_namespace('dc', 'http://purl.org/dc/elements/1.1/')

          channel = root.find('channel')

          # Check if this version already exists
          ns = {'sparkle': 'http://www.andymatuschak.org/xml-namespaces/sparkle'}
          existing = False
          for item in channel.findall('item'):
              short_ver = item.find('sparkle:shortVersionString', ns)
              if short_ver is not None and short_ver.text == "$VERSION":
                  existing = True
                  print(f"Version $VERSION already exists in appcast.xml, updating...")
                  # Update existing item
                  item.find('sparkle:version', ns).text = "$BUILD_NUMBER"
                  enc = item.find('enclosure')
                  enc.set('{http://www.andymatuschak.org/xml-namespaces/sparkle}edSignature', "$SIGNATURE")
                  enc.set('length', "$DMG_SIZE")
                  enc.set('url', "https://github.com/surpriz/Queen_Mama/releases/download/$TAG_NAME/QueenMama-$VERSION.dmg")
                  break

          if not existing:
              # Create new item
              item = ET.SubElement(channel, 'item')

              title = ET.SubElement(item, 'title')
              title.text = "Version $VERSION"

              desc = ET.SubElement(item, 'description')
              desc.text = """
          Queen Mama $VERSION - Nouvelle version disponible.
          Consultez les notes de version sur GitHub pour plus de d√©tails.
              """

              pub_date = ET.SubElement(item, 'pubDate')
              pub_date.text = datetime.now(timezone.utc).strftime('%a, %d %b %Y %H:%M:%S +0000')

              version = ET.SubElement(item, '{http://www.andymatuschak.org/xml-namespaces/sparkle}version')
              version.text = "$BUILD_NUMBER"

              short_version = ET.SubElement(item, '{http://www.andymatuschak.org/xml-namespaces/sparkle}shortVersionString')
              short_version.text = "$VERSION"

              min_sys = ET.SubElement(item, '{http://www.andymatuschak.org/xml-namespaces/sparkle}minimumSystemVersion')
              min_sys.text = "14.2"

              enclosure = ET.SubElement(item, 'enclosure')
              enclosure.set('url', "https://github.com/surpriz/Queen_Mama/releases/download/$TAG_NAME/QueenMama-$VERSION.dmg")
              enclosure.set('{http://www.andymatuschak.org/xml-namespaces/sparkle}edSignature', "$SIGNATURE")
              enclosure.set('length', "$DMG_SIZE")
              enclosure.set('type', 'application/octet-stream')

              print(f"Added new version $VERSION to appcast.xml")

          # Write back
          tree.write('landing/public/appcast.xml', encoding='utf-8', xml_declaration=True)
          print("‚úÖ appcast.xml updated successfully")
          PYTHON_SCRIPT

          # Commit and push
          git add landing/public/appcast.xml
          git commit -m "Update appcast.xml for version $VERSION

          Sparkle auto-update feed updated automatically by CI.

          Co-Authored-By: github-actions[bot] <github-actions[bot]@users.noreply.github.com>"

          git push origin main

          echo "‚úÖ appcast.xml updated and pushed to main"

      - name: Cleanup
        if: always()
        run: security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true
