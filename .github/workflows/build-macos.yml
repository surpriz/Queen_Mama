name: Build macOS App

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version (e.g., 1.0.0 or 1.0.0-beta.1)'
        required: true
        default: '1.0.0'
      prerelease:
        description: 'Pre-release (for staging)'
        type: boolean
        default: false

env:
  SCHEME: QueenMama
  XCODE_PROJECT: QueenMama.xcodeproj
  TEAM_ID: WNNDDTBPGK

jobs:
  build:
    runs-on: macos-14
    timeout-minutes: 30  # Prevent infinite hangs
    permissions:
      contents: write  # Required for creating releases
    steps:
      - uses: actions/checkout@v4

      - name: Determine release type
        id: release_type
        run: |
          TAG_NAME="${GITHUB_REF_NAME:-${{ github.event.inputs.version }}}"
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT

          # Check if it's a pre-release (contains -beta, -rc, -alpha, etc.)
          if [[ "$TAG_NAME" =~ -(beta|rc|alpha|dev) ]] || [[ "${{ github.event.inputs.prerelease }}" == "true" ]]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
            echo "üì¶ Building PRE-RELEASE: $TAG_NAME"
          else
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
            echo "üöÄ Building PRODUCTION RELEASE: $TAG_NAME"
          fi

      - name: Calculate next build number
        id: build_number
        run: |
          # Fetch the current highest build number from appcast.xml
          CURRENT_BUILD=$(curl -sL "https://www.queenmama.co/appcast.xml" | grep -o 'sparkle:version>[0-9]*<' | grep -o '[0-9]*' | sort -n | tail -1)

          if [ -z "$CURRENT_BUILD" ]; then
            CURRENT_BUILD=15  # Fallback to current known build
          fi

          NEXT_BUILD=$((CURRENT_BUILD + 1))
          echo "current_build=$CURRENT_BUILD" >> $GITHUB_OUTPUT
          echo "next_build=$NEXT_BUILD" >> $GITHUB_OUTPUT
          echo "üìä Current build: $CURRENT_BUILD, Next build: $NEXT_BUILD"

      - name: Update Info.plist with new build number
        run: |
          TAG_NAME="${GITHUB_REF_NAME:-${{ github.event.inputs.version }}}"
          VERSION="${TAG_NAME#v}"
          BUILD_NUMBER="${{ steps.build_number.outputs.next_build }}"

          # Update CFBundleShortVersionString
          /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString $VERSION" mac_app/Info.plist

          # Update CFBundleVersion (build number)
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $BUILD_NUMBER" mac_app/Info.plist

          echo "üìù Updated Info.plist: Version=$VERSION, Build=$BUILD_NUMBER"

          # Verify
          echo "Verification:"
          /usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" mac_app/Info.plist
          /usr/libexec/PlistBuddy -c "Print :CFBundleVersion" mac_app/Info.plist

      - name: Select Xcode
        run: sudo xcode-select -s /Applications/Xcode_16.2.app

      - name: Install Certificate
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Import certificate
          echo -n "$APPLE_CERTIFICATE" | base64 --decode -o $RUNNER_TEMP/certificate.p12
          security import $RUNNER_TEMP/certificate.p12 \
            -P "$APPLE_CERTIFICATE_PASSWORD" \
            -A \
            -t cert \
            -f pkcs12 \
            -k $KEYCHAIN_PATH

          # Add to keychain search list and set as default
          security list-keychain -d user -s $KEYCHAIN_PATH $(security list-keychains -d user | sed 's/"//g')
          security default-keychain -s $KEYCHAIN_PATH

          # Set partition list
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Verify certificate is available
          echo "Available signing identities:"
          security find-identity -v -p codesigning $KEYCHAIN_PATH

      - name: Build Archive
        run: |
          # Build without signing Swift packages (they'll be re-signed in Export step)
          xcodebuild archive \
            -project $XCODE_PROJECT \
            -scheme $SCHEME \
            -configuration Release \
            -archivePath $RUNNER_TEMP/QueenMama.xcarchive \
            CODE_SIGN_IDENTITY=- \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO \
            -skipPackagePluginValidation \
            -skipMacroValidation

      - name: Upload dSYMs to Sentry
        if: ${{ vars.SENTRY_ORG != '' }}
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ vars.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ vars.SENTRY_PROJECT }}
        run: |
          TAG_NAME="${{ steps.release_type.outputs.tag_name }}"
          VERSION="${TAG_NAME#v}"
          BUILD_NUMBER="${{ steps.build_number.outputs.next_build }}"

          echo "üì§ Installing sentry-cli..."
          curl -sL https://sentry.io/get-cli/ | bash

          echo "üì§ Creating Sentry release ${VERSION}+${BUILD_NUMBER}..."
          sentry-cli releases new "${VERSION}+${BUILD_NUMBER}"

          echo "üì§ Associating commits..."
          sentry-cli releases set-commits "${VERSION}+${BUILD_NUMBER}" --auto

          echo "üì§ Uploading dSYMs from archive..."
          sentry-cli debug-files upload --include-sources \
            "$RUNNER_TEMP/QueenMama.xcarchive/dSYMs"

          echo "‚úÖ dSYMs uploaded to Sentry"

      - name: Export App
        run: |
          # Create export directory
          mkdir -p "$RUNNER_TEMP/export"

          # Copy app from archive (not signed during archive step - we sign manually)
          cp -R "$RUNNER_TEMP/QueenMama.xcarchive/Products/Applications/QueenMama.app" "$RUNNER_TEMP/export/Queen Mama.app"

          APP_PATH="$RUNNER_TEMP/export/Queen Mama.app"
          SIGN_IDENTITY="Developer ID Application: Jerome LAVAL (WNNDDTBPGK)"

          echo "üîê Signing all frameworks and nested components..."
          echo "üìÇ Contents of Frameworks directory:"
          find "$APP_PATH/Contents/Frameworks" -type f -perm +111 | head -50

          # Step 1: Sign ALL executable binaries first (deepest paths first)
          echo "üîê Step 1: Signing all executable binaries..."
          find "$APP_PATH/Contents/Frameworks" -type f -perm +111 | sort -r | while read exe; do
            echo "Signing binary: $exe"
            codesign --force --timestamp --options runtime --sign "$SIGN_IDENTITY" "$exe"
          done

          # Step 2: Sign XPC services (after their binaries are signed)
          echo "üîê Step 2: Signing XPC services..."
          find "$APP_PATH/Contents/Frameworks" -type d -name "*.xpc" | while read xpc; do
            echo "Signing XPC: $xpc"
            codesign --force --timestamp --options runtime --sign "$SIGN_IDENTITY" "$xpc"
          done

          # Step 3: Sign helper apps (after their contents are signed)
          echo "üîê Step 3: Signing helper apps..."
          find "$APP_PATH/Contents/Frameworks" -type d -name "*.app" | while read app; do
            echo "Signing helper app: $app"
            codesign --force --timestamp --options runtime --sign "$SIGN_IDENTITY" "$app"
          done

          # Step 4: Sign all frameworks (deepest first)
          echo "üîê Step 4: Signing frameworks..."
          find "$APP_PATH/Contents/Frameworks" -type d -name "*.framework" | sort -r | while read fw; do
            echo "Signing framework: $fw"
            codesign --force --timestamp --options runtime --sign "$SIGN_IDENTITY" "$fw"
          done

          # Step 5: Sign the main app with entitlements
          echo "üîê Step 5: Signing main application..."
          codesign --force --timestamp --options runtime \
            --sign "$SIGN_IDENTITY" \
            --entitlements "mac_app/QueenMama.entitlements" \
            "$APP_PATH"

          # Verify all signatures
          echo "‚úÖ Verifying code signatures:"
          codesign -dv --verbose=2 "$APP_PATH"
          codesign --verify --deep --strict "$APP_PATH" && echo "Deep verification passed!"

      - name: Notarize App
        timeout-minutes: 15
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
        run: |
          echo "üì§ Submitting app for notarization..."
          ditto -c -k --keepParent "$RUNNER_TEMP/export/Queen Mama.app" $RUNNER_TEMP/QueenMama.zip

          # Submit and wait for notarization
          xcrun notarytool submit $RUNNER_TEMP/QueenMama.zip \
            --apple-id "$APPLE_ID" \
            --team-id "$APPLE_TEAM_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" \
            --wait \
            --output-format json > /tmp/notarize_result.json 2>&1 || true

          cat /tmp/notarize_result.json

          # Extract status from JSON
          STATUS=$(cat /tmp/notarize_result.json | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('status','Unknown'))" 2>/dev/null || echo "Unknown")
          SUBMISSION_ID=$(cat /tmp/notarize_result.json | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('id',''))" 2>/dev/null || echo "")

          echo "Notarization status: $STATUS"
          echo "Submission ID: $SUBMISSION_ID"

          if [ "$STATUS" = "Accepted" ]; then
            echo "‚úÖ App notarization successful!"
            xcrun stapler staple "$RUNNER_TEMP/export/Queen Mama.app"
            xcrun stapler validate "$RUNNER_TEMP/export/Queen Mama.app"
          else
            echo "‚ùå App notarization FAILED with status: $STATUS"
            if [ -n "$SUBMISSION_ID" ]; then
              echo "üìã Fetching notarization log..."
              xcrun notarytool log "$SUBMISSION_ID" \
                --apple-id "$APPLE_ID" \
                --team-id "$APPLE_TEAM_ID" \
                --password "$APPLE_APP_SPECIFIC_PASSWORD" || true
            fi
            exit 1
          fi

      - name: Create DMG
        run: |
          # Create a folder for DMG contents
          mkdir -p "$RUNNER_TEMP/dmg-contents"
          cp -R "$RUNNER_TEMP/export/Queen Mama.app" "$RUNNER_TEMP/dmg-contents/"

          # Add symbolic link to Applications folder
          ln -s /Applications "$RUNNER_TEMP/dmg-contents/Applications"

          # Create DMG with both app and Applications shortcut
          hdiutil create -volname "Queen Mama" \
            -srcfolder "$RUNNER_TEMP/dmg-contents" \
            -ov -format UDZO \
            $RUNNER_TEMP/QueenMama.dmg

          echo "üì¶ DMG created: $(ls -lh $RUNNER_TEMP/QueenMama.dmg)"

      - name: Notarize DMG
        timeout-minutes: 15
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
        run: |
          echo "üì§ Submitting DMG for notarization..."
          xcrun notarytool submit $RUNNER_TEMP/QueenMama.dmg \
            --apple-id "$APPLE_ID" \
            --team-id "$APPLE_TEAM_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" \
            --wait \
            --output-format json > /tmp/dmg_notarize_result.json 2>&1 || true

          cat /tmp/dmg_notarize_result.json

          STATUS=$(cat /tmp/dmg_notarize_result.json | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('status','Unknown'))" 2>/dev/null || echo "Unknown")
          SUBMISSION_ID=$(cat /tmp/dmg_notarize_result.json | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('id',''))" 2>/dev/null || echo "")

          echo "DMG notarization status: $STATUS"

          if [ "$STATUS" = "Accepted" ]; then
            echo "‚úÖ DMG notarization successful!"
            xcrun stapler staple $RUNNER_TEMP/QueenMama.dmg
            xcrun stapler validate $RUNNER_TEMP/QueenMama.dmg
            echo "‚úÖ DMG stapled and validated!"
          else
            echo "‚ùå DMG notarization FAILED with status: $STATUS"
            if [ -n "$SUBMISSION_ID" ]; then
              echo "üìã Fetching notarization log..."
              xcrun notarytool log "$SUBMISSION_ID" \
                --apple-id "$APPLE_ID" \
                --team-id "$APPLE_TEAM_ID" \
                --password "$APPLE_APP_SPECIFIC_PASSWORD" || true
            fi
            exit 1
          fi

      - name: Get version info
        id: version_info
        run: |
          TAG_NAME="${{ steps.release_type.outputs.tag_name }}"
          # Extract version without 'v' prefix
          VERSION="${TAG_NAME#v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

          # Get build number from Info.plist
          BUILD_NUMBER=$(defaults read "$RUNNER_TEMP/export/Queen Mama.app/Contents/Info" CFBundleVersion)
          echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT

          # Get DMG size
          DMG_SIZE=$(stat -f%z "$RUNNER_TEMP/QueenMama.dmg")
          echo "dmg_size=$DMG_SIZE" >> $GITHUB_OUTPUT

          echo "üì¶ Version: $VERSION, Build: $BUILD_NUMBER, DMG Size: $DMG_SIZE bytes"

      - name: Sign DMG for Sparkle
        id: sparkle_sign
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
        run: |
          if [ -z "$SPARKLE_PRIVATE_KEY" ]; then
            echo "‚ö†Ô∏è SPARKLE_PRIVATE_KEY not set, skipping Sparkle signing"
            echo "signature=" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Download Sparkle tools
          echo "üì• Downloading Sparkle tools..."
          curl -L -o /tmp/Sparkle.tar.xz "https://github.com/sparkle-project/Sparkle/releases/download/2.6.4/Sparkle-2.6.4.tar.xz"
          mkdir -p /tmp/sparkle
          tar -xf /tmp/Sparkle.tar.xz -C /tmp/sparkle

          # Save private key to temp file
          echo "$SPARKLE_PRIVATE_KEY" > /tmp/sparkle_private_key

          # Sign the DMG
          echo "üîê Signing DMG for Sparkle updates..."
          SIGNATURE=$(/tmp/sparkle/bin/sign_update "$RUNNER_TEMP/QueenMama.dmg" --ed-key-file /tmp/sparkle_private_key | grep "sparkle:edSignature" | sed 's/.*sparkle:edSignature="\([^"]*\)".*/\1/')

          # Clean up private key
          rm -f /tmp/sparkle_private_key

          echo "‚úÖ Sparkle signature generated"
          echo "signature=$SIGNATURE" >> $GITHUB_OUTPUT

      - name: Rename DMG with version
        run: |
          VERSION="${{ steps.version_info.outputs.version }}"
          mv "$RUNNER_TEMP/QueenMama.dmg" "$RUNNER_TEMP/QueenMama-${VERSION}.dmg"
          echo "üì¶ DMG renamed to: QueenMama-${VERSION}.dmg"

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          files: ${{ runner.temp }}/QueenMama-${{ steps.version_info.outputs.version }}.dmg
          prerelease: ${{ steps.release_type.outputs.is_prerelease }}
          body: |
            ## Queen Mama ${{ steps.release_type.outputs.tag_name }}

            ${{ steps.release_type.outputs.is_prerelease == 'true' && '‚ö†Ô∏è **PRE-RELEASE** - Pour tests uniquement (staging.queenmama.co)' || 'üöÄ **PRODUCTION RELEASE** - Version stable (queenmama.co)' }}

            **Installation:** T√©l√©charger le DMG, glisser dans Applications.
            **Requis:** macOS 14.2+
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Finalize Sentry Release
        if: ${{ vars.SENTRY_ORG != '' }}
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ vars.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ vars.SENTRY_PROJECT }}
        run: |
          VERSION="${{ steps.version_info.outputs.version }}"
          BUILD_NUMBER="${{ steps.version_info.outputs.build_number }}"

          echo "üöÄ Finalizing Sentry release ${VERSION}+${BUILD_NUMBER}..."
          sentry-cli releases finalize "${VERSION}+${BUILD_NUMBER}"

          # Mark as deployed for the appropriate environment
          if [[ "${{ steps.release_type.outputs.is_prerelease }}" == "true" ]]; then
            sentry-cli releases deploys "${VERSION}+${BUILD_NUMBER}" new -e staging
            echo "‚úÖ Marked as deployed to staging"
          else
            sentry-cli releases deploys "${VERSION}+${BUILD_NUMBER}" new -e production
            echo "‚úÖ Marked as deployed to production"
          fi

      - name: Update appcast.xml
        if: steps.sparkle_sign.outputs.signature != '' && steps.release_type.outputs.is_prerelease == 'false'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ steps.version_info.outputs.version }}"
          BUILD_NUMBER="${{ steps.version_info.outputs.build_number }}"
          DMG_SIZE="${{ steps.version_info.outputs.dmg_size }}"
          SIGNATURE="${{ steps.sparkle_sign.outputs.signature }}"
          TAG_NAME="${{ steps.release_type.outputs.tag_name }}"

          echo "üìù Updating appcast.xml for version $VERSION..."

          # Configure git
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          # Checkout main branch
          git fetch origin main
          git checkout main

          # Use Python to safely update XML
          python3 << PYTHON_SCRIPT
          import xml.etree.ElementTree as ET
          from datetime import datetime, timezone

          # Parse existing appcast
          tree = ET.parse('landing/public/appcast.xml')
          root = tree.getroot()

          # Register Sparkle namespace
          ET.register_namespace('sparkle', 'http://www.andymatuschak.org/xml-namespaces/sparkle')
          ET.register_namespace('dc', 'http://purl.org/dc/elements/1.1/')

          channel = root.find('channel')

          # Check if this version already exists
          ns = {'sparkle': 'http://www.andymatuschak.org/xml-namespaces/sparkle'}
          existing = False
          for item in channel.findall('item'):
              short_ver = item.find('sparkle:shortVersionString', ns)
              if short_ver is not None and short_ver.text == "$VERSION":
                  existing = True
                  print(f"Version $VERSION already exists in appcast.xml, updating...")
                  # Update existing item
                  item.find('sparkle:version', ns).text = "$BUILD_NUMBER"
                  enc = item.find('enclosure')
                  enc.set('{http://www.andymatuschak.org/xml-namespaces/sparkle}edSignature', "$SIGNATURE")
                  enc.set('length', "$DMG_SIZE")
                  enc.set('url', "https://github.com/surpriz/Queen_Mama/releases/download/$TAG_NAME/QueenMama-$VERSION.dmg")
                  break

          if not existing:
              # Create new item
              item = ET.SubElement(channel, 'item')

              title = ET.SubElement(item, 'title')
              title.text = "Version $VERSION"

              desc = ET.SubElement(item, 'description')
              desc.text = """
          Queen Mama $VERSION - Nouvelle version disponible.
          Consultez les notes de version sur GitHub pour plus de d√©tails.
              """

              pub_date = ET.SubElement(item, 'pubDate')
              pub_date.text = datetime.now(timezone.utc).strftime('%a, %d %b %Y %H:%M:%S +0000')

              version = ET.SubElement(item, '{http://www.andymatuschak.org/xml-namespaces/sparkle}version')
              version.text = "$BUILD_NUMBER"

              short_version = ET.SubElement(item, '{http://www.andymatuschak.org/xml-namespaces/sparkle}shortVersionString')
              short_version.text = "$VERSION"

              min_sys = ET.SubElement(item, '{http://www.andymatuschak.org/xml-namespaces/sparkle}minimumSystemVersion')
              min_sys.text = "14.2"

              enclosure = ET.SubElement(item, 'enclosure')
              enclosure.set('url', "https://github.com/surpriz/Queen_Mama/releases/download/$TAG_NAME/QueenMama-$VERSION.dmg")
              enclosure.set('{http://www.andymatuschak.org/xml-namespaces/sparkle}edSignature', "$SIGNATURE")
              enclosure.set('length', "$DMG_SIZE")
              enclosure.set('type', 'application/octet-stream')

              print(f"Added new version $VERSION to appcast.xml")

          # Write back
          tree.write('landing/public/appcast.xml', encoding='utf-8', xml_declaration=True)
          print("‚úÖ appcast.xml updated successfully")
          PYTHON_SCRIPT

          # Commit and push
          git add landing/public/appcast.xml
          git commit -m "Update appcast.xml for version $VERSION

          Sparkle auto-update feed updated automatically by CI.

          Co-Authored-By: github-actions[bot] <github-actions[bot]@users.noreply.github.com>"

          git push origin main

          echo "‚úÖ appcast.xml updated and pushed to main"

      - name: Cleanup
        if: always()
        run: security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true
